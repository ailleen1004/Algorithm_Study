# Knapsack Problem
## Problem
아래의 주어진 배낭의 최대 용량(무게)과 보석의 무게 및 가치를 고려하 여 배낭에 담은 보석이 최대한의 가치를 가지도록 담는 방법을 구하시오.

### 입력 1
- 배낭 무게 : 15
- 보석 (무게, 가치) : (5, 5), (10, 7), (7, 10), (3, 6), (4, 8), (11, 20)

### 입력 3
- 배낭 무게 : 30
- 보석 (무게, 가치) : (3, 5), (7, 7), (8, 10), (5, 6), (6, 8), (13, 20), (11, 18), (2, 5)
<br/><br/>
## Result
Maximum value that can be obtained: 28<br/>
Maximum value that can be obtained: 48
<br/><br/>
## Explanation
위 코드는 dynamic programming을 적용하였으며, 2차원 배열 dp를 선언하여 어떠한 보석을 선택했을 때 주어진 배낭의 무게를 고려해서 넣을 수 있는 보석의 최대 가치를 저장한다.
knapsack() 함수 안에서는 2중 반복문이 사용되었으며, 점화식은 다음과 같다.

--------------------------------------------------------------------------------------------------------------
weight = 보석의 무게, value = 보석의 가치<br/>
dp[i][j] = i번째 보석까지 고려하고, 배낭의 무게가 j일때, 얻을 수 있는 최대 가치

![image](https://github.com/ailleen1004/Algorithm_Study/assets/38450827/e7818435-805a-40f8-a765-6a3d94b3ba26)
<br/>
1. i번째 보석을 배낭에 넣을 수 없는 경우 (weight > j)
- dp[i][j]은 전 상황에서 배낭의 무게가 w일 때 최대 가치인 dp[i-1][j]가 된다.
2. i번째 보석을 배낭에 넣을 수 있는 경우 (weight <= j)
- (1) {(i번째 보석의 가치인 value[i-1]) + (i-1번째 보석까지의 배낭의 무게인 j-weight[i-1]일 때 최대 가치인 dp[i-1])}
- (2) (전 상황에서 배낭 무게가 w일 때 최대 가치인 dp[i-1][j])
- 위 두 값 중 더 큰 값이 dp[i][j]가 된다.
--------------------------------------------------------------------------------------------------------------
위 과정을 모두 수행하면 dp[보석 정보가 담긴 vector size][배낭의 무게]가 최대 가치가 된다.
