# 숫자판 놀이
## Problem
- 숫자들이 2차원 배열에 있다.
- 가장 윗 행에서 가장 아래 행까지 내려올 때 걸쳐지는 길에 있는 숫자의 합이 가장 높은 값을 찾아보자.
- 아래의 숫자판 배열을 어느 한 cell에서 다음 cell로 내려올 경우에는 바로 아래, 왼쪽 대각선 아래, 오른쪽 대각선 아래로만 이동이 가능하다.

int array[8][9] = {<br/>
  { 3, 4, 9, -2, 2, 51, -23, 2, -1},<br/>
  { 223,7,8,-11,5, -99,2,3, -4 },<br/>
  { 2,51,-23, -23,6,3,2,4,5 },<br/>
  { 5,-99,2,-1,32,2,5,-99,2 },<br/>
  { 6,3,3,-4,2,-1,6,3,3 },<br/>
  { 32,2,4,5,3,-4,2,-1,4 },<br/>
  { 4,4,23,6,2,-1,3,-4,34 },<br/>
  { 78,32,1,7,3,-4,-23,-23,6 },<br/>
};<br/><br/>

## Result
Max : 403<br/>
Route :<br/>
{ 4, 223, 51, 5, 6, 32, 4, 78 }
<br/><br/>

## Explanation
경로 탐색 과정은 다음과 같다.
1. 지나가는 경로의 원소들의 합이 가장 크도록 탐색한 경로와, 그 합을 저장할 2차원 배열 result를 선언한다.
2. 이 result에는 원본 array의 0번째 행에서 어떠한 수를 선택하는지에 나뉘는 경로를 배열로 저장하고, 그 배열의 맨 앞 0번째 원소에는 원소들의 합을 저장한다.
3. for문을 통해 array의 최대 합 경로를 찾는다. 최대 합을 가지려면, 왼쪽, 가운데, 오른쪽 값 중 가장 큰 값을 선택해야 하기 때문에 max 함수를 이용하여 최대값을 찾았다.
4. 이때, if 조건문을 통하여 탐색할 왼쪽 대각선 값이 존재하지 않거나, 오른쪽 대각선 값이 존재하지 않는 것을 고려하여 경우를 나누어 주었다. 이는 현재 위치의 열 index 값이 저장된 n값을 통해 알 수 있다.
5. 탐색된 최대값은 원소의 합이 저장되는 result[][0]에 더해다.

모든 경로의 탐색이 끝나 result 배열을 출력해준 결과, 위와 같은 결과가 나왔다.

sum1 : 402 / { 3, 223, 51, 5, 6, 32, 4, 78, }<br/>
sum2 : 403 / { 4, 223, 51, 5, 6, 32, 4, 78, }<br/>
sum3 : 193 / { 9, 8, 51, 5, 6, 32, 4, 78, }<br/>
sum4 : 182 / { -2, 8, 51, 5, 6, 32, 4, 78, }<br/>
sum5 : 107 / { 2, 5, 6, 32, 2, 5, 23, 32, }<br/>
sum6 : 156 / { 51, 5, 6, 32, 2, 5, 23, 32, }<br/>
sum7 : 34 / { -23, 3, 5, 2, 3, 4, 34, 6, }<br/>
sum8 : 59 / { 2, 3, 5, 2, 3, 4, 34, 6, }<br/>
sum9 : 56 / { -1, 3, 5, 2, 3, 4, 34, 6, }<br/>

여기에서 합의 최댓값을 비교하는 for문을 작성해주고, 비교하여 나온 max와 index값을 이용하여 최종 출력해준다.
